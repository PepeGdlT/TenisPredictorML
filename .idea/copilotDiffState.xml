<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/notebooks/predict_tournament.ipynb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/notebooks/predict_tournament.ipynb" />
              <option name="originalContent" value="#%%&#10;" />
              <option name="updatedContent" value="{&#10; &quot;cells&quot;: [&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;# Predicción de Partidos del Australian Open 2025&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;Este notebook carga los datos de un torneo específico (en este caso, el Australian Open 2025), genera las features necesarias y utiliza el modelo entrenado para predecir los resultados.&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;import pandas as pd\n&quot;,&#10;    &quot;import numpy as np\n&quot;,&#10;    &quot;import joblib\n&quot;,&#10;    &quot;import json\n&quot;,&#10;    &quot;import sys\n&quot;,&#10;    &quot;import os\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Añadir el directorio src al path para poder importar los módulos\n&quot;,&#10;    &quot;sys.path.append(os.path.abspath('../src'))\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;from preprocess import preprocess_data\n&quot;,&#10;    &quot;from features import (create_elo_features, create_ranking_features, \n&quot;,&#10;    &quot;                      create_head_to_head_features, create_time_features, \n&quot;,&#10;    &quot;                      create_fatigue_features, create_recent_form_features)\n&quot;,&#10;    &quot;from utils import load_config&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 1. Cargar Datos del Torneo&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;tournament_df = pd.read_csv('../data/raw/test/atp_matches_2025.csv')&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 2. Cargar Datos Procesados (ELOs)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;with open('../data/processed/final_global_elos.json', 'r') as f:\n&quot;,&#10;    &quot;    global_elos = json.load(f)\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;with open('../data/processed/final_surface_elos.json', 'r') as f:\n&quot;,&#10;    &quot;    surface_elos = json.load(f)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 3. Preprocesamiento y Generación de Features&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Cargar configuración\n&quot;,&#10;    &quot;config = load_config('../src/config.yml')\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Preprocesar datos\n&quot;,&#10;    &quot;data = preprocess_data(tournament_df, config['preprocessing'])\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Generar Features\n&quot;,&#10;    &quot;data = create_elo_features(data, global_elos, surface_elos)\n&quot;,&#10;    &quot;data = create_ranking_features(data)\n&quot;,&#10;    &quot;data = create_time_features(data)\n&quot;,&#10;    &quot;data = create_head_to_head_features(data)\n&quot;,&#10;    &quot;data = create_fatigue_features(data, config['feature_engineering']['fatigue'])\n&quot;,&#10;    &quot;data = create_recent_form_features(data, config['feature_engineering']['form'])\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Seleccionar solo las columnas de features\n&quot;,&#10;    &quot;features_df = data[config['model']['features']]\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;print(\&quot;Features generadas exitosamente.\&quot;)\n&quot;,&#10;    &quot;features_df.head()&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 4. Cargar Modelo y Realizar Predicciones&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Cargar el modelo entrenado\n&quot;,&#10;    &quot;model = joblib.load('../outputs/models/atp_tennis_predictor.joblib')\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Realizar predicciones\n&quot;,&#10;    &quot;predictions = model.predict(features_df)\n&quot;,&#10;    &quot;prediction_probs = model.predict_proba(features_df)[:, 1] # Probabilidad de que gane el jugador 1&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 5. Comparar Resultados&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;results_df = data[['player_1', 'player_2', 'winner']].copy()\n&quot;,&#10;    &quot;results_df['predicted_winner_code'] = predictions\n&quot;,&#10;    &quot;results_df['p1_win_probability'] = prediction_probs\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Mapear códigos a nombres de jugadores\n&quot;,&#10;    &quot;results_df['predicted_winner'] = np.where(results_df['predicted_winner_code'] == 1, results_df['player_1'], results_df['player_2'])\n&quot;,&#10;    &quot;results_df['actual_winner'] = np.where(results_df['winner'] == 1, results_df['player_1'], results_df['player_2'])\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Mostrar resultados\n&quot;,&#10;    &quot;comparison_df = results_df[['player_1', 'player_2', 'actual_winner', 'predicted_winner', 'p1_win_probability']]\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;print(\&quot;Tabla de Comparación de Resultados:\&quot;)\n&quot;,&#10;    &quot;comparison_df&quot;&#10;   ]&#10;  }&#10; ],&#10; &quot;metadata&quot;: {&#10;  &quot;kernelspec&quot;: {&#10;   &quot;display_name&quot;: &quot;Python 3&quot;,&#10;   &quot;language&quot;: &quot;python&quot;,&#10;   &quot;name&quot;: &quot;python3&quot;&#10;  },&#10;  &quot;language_info&quot;: {&#10;   &quot;codemirror_mode&quot;: {&#10;    &quot;name&quot;: &quot;ipython&quot;,&#10;    &quot;version&quot;: 3&#10;   },&#10;   &quot;file_extension&quot;: &quot;.py&quot;,&#10;   &quot;mimetype&quot;: &quot;text/x-python&quot;,&#10;   &quot;name&quot;: &quot;python&quot;,&#10;   &quot;nbconvert_exporter&quot;: &quot;python&quot;,&#10;   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,&#10;   &quot;version&quot;: &quot;3.11.0&quot;&#10;  }&#10; },&#10; &quot;nbformat&quot;: 4,&#10; &quot;nbformat_minor&quot;: 4&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/notebooks/si.ipynb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/notebooks/si.ipynb" />
              <option name="originalContent" value="#%%&#10;" />
              <option name="updatedContent" value="{&#10; &quot;cells&quot;: [&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;# Tennis Feature Engineering Notebook\n\nEste notebook crea un dataset limpio y balanceado para predicción de partidos de tenis, evitando data leakage y generando las features avanzadas que has pedido.&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 1. Cargar datos raw&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;import pandas as pd\nimport numpy as np\nimport os\nfrom src.data_loader import BASE_DIR\n\n# Cargar todos los datos raw de train y test\ntrain_folder = os.path.join(BASE_DIR, 'data', 'raw', 'train')\ntest_folder = os.path.join(BASE_DIR, 'data', 'raw', 'test')\n\ndef load_all_raw(folder):\n    dfs = []\n    for f in os.listdir(folder):\n        if f.endswith('.csv'):\n            df = pd.read_csv(os.path.join(folder, f))\n            dfs.append(df)\n    return pd.concat(dfs, ignore_index=True)\n\ndf_train_raw = load_all_raw(train_folder)\ndf_test_raw = load_all_raw(test_folder)\nprint('Train shape:', df_train_raw.shape)\nprint('Test shape:', df_test_raw.shape)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 2. Limpiar datos&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;from src.preprocess import clean_data\n\ndf_train = clean_data(df_train_raw)\ndf_test = clean_data(df_test_raw)\nprint('Train limpio:', df_train.shape)\nprint('Test limpio:', df_test.shape)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 3. Ingeniería de features&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;from src.features import add_all_features\n\n# Generar features avanzadas (ELO, H2H, etc.)\ndf_train_feat, final_global_elos, final_surface_elos, final_h2h = add_all_features(df_train)\ndf_test_feat, _, _, _ = add_all_features(df_test, initial_global_elos=final_global_elos, initial_surface_elos=final_surface_elos, initial_h2h=final_h2h)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 4. Crear dataset player_1/player_2 y target aleatorio&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;import random\n\ndef make_player1_player2_rows(df):\n    rows = []\n    for _, row in df.iterrows():\n        if random.random() &lt; 0.5:\n            p1, p2 = row['winner_name'], row['loser_name']\n            target = 1\n        else:\n            p1, p2 = row['loser_name'], row['winner_name']\n            target = 0\n        new_row = row.copy()\n        new_row['player_1'] = p1\n        new_row['player_2'] = p2\n        new_row['target'] = target\n        rows.append(new_row)\n    return pd.DataFrame(rows)\n\ndf_train_final = make_player1_player2_rows(df_train_feat)\ndf_test_final = make_player1_player2_rows(df_test_feat)\nprint('Train final:', df_train_final.shape)\nprint('Test final:', df_test_final.shape)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 5. Selección de features&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;features = [\n    'p_ace', 'p_df', 'p_1stIn', 'p_1stWon', 'p_2ndWon', 'p_bpSaved', 'p_retAceAgainst',\n    'elo_winner', 'elo_loser', 'elo_diff', 'surface_elo_winner', 'surface_elo_loser', 'surface_elo_diff',\n    'elo_advantage', 'surface_elo_advantage', 'elo_surface_interaction', 'elo_consistency',\n    'matches_played', 'matches_surface_played', 'last_k_matches',\n    'h2h_count', 'h2h_balance', 'h2h_surface',\n    # Puedes añadir más features aquí\n]\n\nX_train = df_train_final[features]\ny_train = df_train_final['target']\nX_test = df_test_final[features]\ny_test = df_test_final['target']&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 6. Guardar dataset final&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;output_dir = os.path.join(BASE_DIR, 'data', 'processed')\ndf_train_final.to_csv(os.path.join(output_dir, 'train_final.csv'), index=False)\ndf_test_final.to_csv(os.path.join(output_dir, 'test_final.csv'), index=False)\nprint('Datasets finales guardados.')&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 7. Auditoría de fuga de información&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;from src.audit_leakage import audit_feature_leakage\n\naudit_feature_leakage(X_train, y_train)&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## 8. Modelado (opcional)\n\nPuedes seguir con el modelado usando el script model.py o añadir una celda aquí para probar modelos.&quot;&#10;   ]&#10;  }&#10; ],&#10; &quot;metadata&quot;: {&#10;  &quot;kernelspec&quot;: {&#10;   &quot;display_name&quot;: &quot;Python 3&quot;,&#10;   &quot;language&quot;: &quot;python&quot;,&#10;   &quot;name&quot;: &quot;python3&quot;&#10;  },&#10;  &quot;language_info&quot;: {&#10;   &quot;name&quot;: &quot;python&quot;,&#10;   &quot;version&quot;: &quot;3.13&quot;&#10;  }&#10; },&#10; &quot;nbformat&quot;: 4,&#10; &quot;nbformat_minor&quot;: 2&#10;}&#10;// ...existing code...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/regenerate_features.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/regenerate_features.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;# Regenerar features con H2H balanceado&#10;&#10;import sys&#10;import os&#10;sys.path.append('C:\\Users\\pepeg\\PycharmProjects\\PythonProject\\src')&#10;&#10;from data_loader import load_train_data, load_test_data, BASE_DIR&#10;from preprocess import clean_data&#10;from features import add_all_features&#10;&#10;# Regenerar features de entrenamiento&#10;print(&quot; Regenerando features de entrenamiento...&quot;)&#10;df_train = load_train_data()&#10;df_train = clean_data(df_train)&#10;df_train = add_all_features(df_train)&#10;&#10;output_path = os.path.join(BASE_DIR, &quot;data&quot;, &quot;processed&quot;)&#10;os.makedirs(output_path, exist_ok=True)&#10;df_train.to_csv(os.path.join(output_path, &quot;features_train.csv&quot;), index=False)&#10;print(&quot;✅ Features de entrenamiento guardadas&quot;)&#10;&#10;# Regenerar features de test&#10;print(&quot; Regenerando features de test...&quot;)&#10;df_test = load_test_data()&#10;df_test = clean_data(df_test)&#10;df_test = add_all_features(df_test)&#10;df_test.to_csv(os.path.join(output_path, &quot;features_test.csv&quot;), index=False)&#10;print(&quot;✅ Features de test guardadas&quot;)&#10;&#10;print(&quot; Regeneración completa!&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/australian_open_2025_simulator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/australian_open_2025_simulator.py" />
              <option name="originalContent" value="# src/australian_open_2025_simulator.py&#10;&#10;import pandas as pd&#10;import numpy as np&#10;import os&#10;from data_loader import BASE_DIR, load_train_data&#10;from preprocess import clean_data&#10;from features import add_all_features, compute_elo_ratings, compute_surface_elo, compute_h2h&#10;from utils import make_dual_rows, fillna_features&#10;from model import train_model&#10;import pickle&#10;from collections import defaultdict&#10;&#10;# simulador completo del australian open 2025 que usa datos históricos&#10;&#10;def extract_historical_elos_and_h2h():&#10;    &quot;&quot;&quot;extrae los elos finales y historial h2h de todos los datos de entrenamiento&quot;&quot;&quot;&#10;    print(&quot;extrayendo elos y h2h históricos...&quot;)&#10;&#10;    # cargar todos los datos históricos&#10;    df_historical = load_train_data()&#10;    df_historical = clean_data(df_historical)&#10;&#10;    # calcular elos progresivamente en todo el dataset histórico&#10;    df_with_features = add_all_features(df_historical)&#10;&#10;    # extraer elos finales de cada jugador&#10;    final_elos = {}&#10;    final_surface_elos = {}&#10;&#10;    # obtener el último elo de cada jugador&#10;    for _, row in df_with_features.iterrows():&#10;        winner = row[&quot;winner_name&quot;]&#10;        loser = row[&quot;loser_name&quot;]&#10;&#10;        final_elos[winner] = row[&quot;elo_winner&quot;]&#10;        final_elos[loser] = row[&quot;elo_loser&quot;]&#10;&#10;        # elos de superficie&#10;        surface = row.get(&quot;surface&quot;, &quot;Hard&quot;)&#10;        final_surface_elos[f&quot;{winner}_{surface}&quot;] = row[&quot;surface_elo_winner&quot;]&#10;        final_surface_elos[f&quot;{loser}_{surface}&quot;] = row[&quot;surface_elo_loser&quot;]&#10;&#10;    # extraer historial h2h completo&#10;    h2h_history = defaultdict(lambda: {&quot;count&quot;: 0, &quot;winner_wins&quot;: 0})&#10;&#10;    for _, row in df_historical.iterrows():&#10;        winner = row[&quot;winner_name&quot;]&#10;        loser = row[&quot;loser_name&quot;]&#10;        pair = tuple(sorted([winner, loser]))&#10;&#10;        h2h_history[pair][&quot;count&quot;] += 1&#10;        # contar victorias del ganador&#10;        if winner == min(pair):  # si el ganador es el primero alfabéticamente&#10;            h2h_history[pair][&quot;winner_wins&quot;] += 1&#10;&#10;    print(f&quot;elos extraídos: {len(final_elos)} jugadores&quot;)&#10;    print(f&quot;h2h extraído: {len(h2h_history)} pares&quot;)&#10;&#10;    return final_elos, final_surface_elos, h2h_history&#10;&#10;def create_ao_2025_r32():&#10;    &quot;&quot;&quot;crea el dataframe base con los partidos de R32 del australian open 2025&quot;&quot;&quot;&#10;&#10;    # emparejamientos reales de la R32 (puedes actualizar con los datos reales)&#10;    r32_matches = [&#10;        # cuarto superior&#10;        {&quot;player1&quot;: &quot;Jannik Sinner&quot;, &quot;player2&quot;: &quot;Nicolas Jarry&quot;},&#10;        {&quot;player1&quot;: &quot;Daniil Medvedev&quot;, &quot;player2&quot;: &quot;Learner Tien&quot;},&#10;        {&quot;player1&quot;: &quot;Alexander Zverev&quot;, &quot;player2&quot;: &quot;Ugo Humbert&quot;},&#10;        {&quot;player1&quot;: &quot;Carlos Alcaraz&quot;, &quot;player2&quot;: &quot;Jack Draper&quot;},&#10;        {&quot;player1&quot;: &quot;Tommy Paul&quot;, &quot;player2&quot;: &quot;Alejandro Davidovich Fokina&quot;},&#10;        {&quot;player1&quot;: &quot;Ben Shelton&quot;, &quot;player2&quot;: &quot;Lorenzo Musetti&quot;},&#10;        {&quot;player1&quot;: &quot;Novak Djokovic&quot;, &quot;player2&quot;: &quot;Jiri Lehecka&quot;},&#10;        {&quot;player1&quot;: &quot;Taylor Fritz&quot;, &quot;player2&quot;: &quot;Gael Monfils&quot;},&#10;&#10;        # cuarto medio-superior&#10;        {&quot;player1&quot;: &quot;Casper Ruud&quot;, &quot;player2&quot;: &quot;Jenson Brooksby&quot;},&#10;        {&quot;player1&quot;: &quot;Alex de Minaur&quot;, &quot;player2&quot;: &quot;Alex Michelsen&quot;},&#10;        {&quot;player1&quot;: &quot;Stefanos Tsitsipas&quot;, &quot;player2&quot;: &quot;Thanasi Kokkinakis&quot;},&#10;        {&quot;player1&quot;: &quot;Sebastian Korda&quot;, &quot;player2&quot;: &quot;Corentin Moutet&quot;},&#10;        {&quot;player1&quot;: &quot;Hubert Hurkacz&quot;, &quot;player2&quot;: &quot;Arthur Fils&quot;},&#10;        {&quot;player1&quot;: &quot;Frances Tiafoe&quot;, &quot;player2&quot;: &quot;Fabian Marozsan&quot;},&#10;        {&quot;player1&quot;: &quot;Grigor Dimitrov&quot;, &quot;player2&quot;: &quot;Rinky Hijikata&quot;},&#10;        {&quot;player1&quot;: &quot;Andrey Rublev&quot;, &quot;player2&quot;: &quot;Jakub Mensik&quot;},&#10;&#10;        # cuarto medio-inferior&#10;        {&quot;player1&quot;: &quot;Holger Rune&quot;, &quot;player2&quot;: &quot;Matteo Berrettini&quot;},&#10;        {&quot;player1&quot;: &quot;Lorenzo Sonego&quot;, &quot;player2&quot;: &quot;Facundo Diaz Acosta&quot;},&#10;        {&quot;player1&quot;: &quot;Felix Auger-Aliassime&quot;, &quot;player2&quot;: &quot;Botic van de Zandschulp&quot;},&#10;        {&quot;player1&quot;: &quot;Karen Khachanov&quot;, &quot;player2&quot;: &quot;Giovanni Mpetshi Perricard&quot;},&#10;        {&quot;player1&quot;: &quot;Sebastian Baez&quot;, &quot;player2&quot;: &quot;Pavel Kotov&quot;},&#10;        {&quot;player1&quot;: &quot;Jordan Thompson&quot;, &quot;player2&quot;: &quot;Adrian Mannarino&quot;},&#10;        {&quot;player1&quot;: &quot;Francisco Cerundolo&quot;, &quot;player2&quot;: &quot;Tomas Martin Etcheverry&quot;},&#10;        {&quot;player1&quot;: &quot;Flavio Cobolli&quot;, &quot;player2&quot;: &quot;James Duckworth&quot;},&#10;&#10;        # cuarto inferior&#10;        {&quot;player1&quot;: &quot;Alexei Popyrin&quot;, &quot;player2&quot;: &quot;Marcos Giron&quot;},&#10;        {&quot;player1&quot;: &quot;Matteo Arnaldi&quot;, &quot;player2&quot;: &quot;Zhang Yifan&quot;},&#10;        {&quot;player1&quot;: &quot;Cameron Norrie&quot;, &quot;player2&quot;: &quot;Yoshihito Nishioka&quot;},&#10;        {&quot;player1&quot;: &quot;Alexander Bublik&quot;, &quot;player2&quot;: &quot;Brandon Nakashima&quot;},&#10;        {&quot;player1&quot;: &quot;Arthur Cazaux&quot;, &quot;player2&quot;: &quot;Nuno Borges&quot;},&#10;        {&quot;player1&quot;: &quot;Daniel Evans&quot;, &quot;player2&quot;: &quot;Quentin Halys&quot;},&#10;        {&quot;player1&quot;: &quot;Roman Safiullin&quot;, &quot;player2&quot;: &quot;Roberto Carballes Baena&quot;},&#10;        {&quot;player1&quot;: &quot;Mariano Navone&quot;, &quot;player2&quot;: &quot;Christopher O'Connell&quot;}&#10;    ]&#10;&#10;    # crear dataframe base&#10;    matches = []&#10;    for i, match in enumerate(r32_matches):&#10;        # crear fila base para cada partido&#10;        row = {&#10;            &quot;tourney_id&quot;: &quot;2025-AO&quot;,&#10;            &quot;tourney_name&quot;: &quot;Australian Open&quot;,&#10;            &quot;surface&quot;: &quot;Hard&quot;,&#10;            &quot;draw_size&quot;: 128,&#10;            &quot;tourney_level&quot;: &quot;G&quot;,&#10;            &quot;tourney_date&quot;: 20250113,  # fecha estimada&#10;            &quot;match_num&quot;: i + 1,&#10;            &quot;winner_name&quot;: match[&quot;player1&quot;],  # placeholder, se determinará por predicción&#10;            &quot;loser_name&quot;: match[&quot;player2&quot;],   # placeholder&#10;            &quot;round&quot;: &quot;R32&quot;,&#10;            &quot;best_of&quot;: 5,&#10;            &quot;score&quot;: None,&#10;            &quot;minutes&quot;: None&#10;        }&#10;&#10;        # columnas requeridas con valores por defecto&#10;        for col in [&quot;winner_id&quot;, &quot;winner_seed&quot;, &quot;winner_hand&quot;, &quot;winner_ht&quot;, &quot;winner_ioc&quot;, &quot;winner_age&quot;,&#10;                   &quot;loser_id&quot;, &quot;loser_seed&quot;, &quot;loser_hand&quot;, &quot;loser_ht&quot;, &quot;loser_ioc&quot;, &quot;loser_age&quot;,&#10;                   &quot;w_ace&quot;, &quot;w_df&quot;, &quot;w_svpt&quot;, &quot;w_1stIn&quot;, &quot;w_1stWon&quot;, &quot;w_2ndWon&quot;, &quot;w_SvGms&quot;, &quot;w_bpSaved&quot;, &quot;w_bpFaced&quot;,&#10;                   &quot;l_ace&quot;, &quot;l_df&quot;, &quot;l_svpt&quot;, &quot;l_1stIn&quot;, &quot;l_1stWon&quot;, &quot;l_2ndWon&quot;, &quot;l_SvGms&quot;, &quot;l_bpSaved&quot;, &quot;l_bpFaced&quot;,&#10;                   &quot;winner_rank&quot;, &quot;winner_rank_points&quot;, &quot;loser_rank&quot;, &quot;loser_rank_points&quot;]:&#10;            row[col] = None&#10;&#10;        matches.append(row)&#10;&#10;    return pd.DataFrame(matches)&#10;&#10;def load_trained_model():&#10;    &quot;&quot;&quot;carga el modelo entrenado o entrena uno nuevo&quot;&quot;&quot;&#10;    model_path = os.path.join(BASE_DIR, &quot;outputs&quot;, &quot;trained_model.pkl&quot;)&#10;&#10;    if os.path.exists(model_path):&#10;        print(&quot;cargando modelo preentrenado...&quot;)&#10;        with open(model_path, 'rb') as f:&#10;            model = pickle.load(f)&#10;&#10;        # obtener las features exactas que usa el modelo&#10;        if hasattr(model, 'feature_names_in_'):&#10;            model_features = list(model.feature_names_in_)&#10;            print(f&quot;modelo entrenado con features: {model_features}&quot;)&#10;            return model, model_features&#10;        else:&#10;            # fallback a features por defecto&#10;            default_features = [&#10;                &quot;elo_winner&quot;, &quot;elo_loser&quot;, &quot;elo_diff&quot;,&#10;                &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;, &quot;surface_elo_diff&quot;,&#10;                &quot;elo_advantage&quot;, &quot;surface_elo_advantage&quot;,&#10;                &quot;rank_diff&quot;, &quot;rank_advantage&quot;, &quot;rank_ratio&quot;, &quot;elo_rank_mismatch&quot;,&#10;                &quot;elo_tier_winner&quot;, &quot;elo_tier_loser&quot;, &quot;tier_diff&quot;,&#10;                &quot;match_competitiveness&quot;, &quot;is_upset_potential&quot;,&#10;                &quot;h2h_count&quot;, &quot;h2h_balance&quot;&#10;            ]&#10;            return model, default_features&#10;    else:&#10;        print(&quot;entrenando nuevo modelo...&quot;)&#10;        # cargar datos de entrenamiento&#10;        features_train_path = os.path.join(BASE_DIR, &quot;data&quot;, &quot;processed&quot;, &quot;features_train.csv&quot;)&#10;        df_train = pd.read_csv(features_train_path)&#10;        df_train = make_dual_rows(df_train)&#10;&#10;        feature_cols = [&#10;            &quot;elo_winner&quot;, &quot;elo_loser&quot;, &quot;elo_diff&quot;,&#10;            &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;, &quot;surface_elo_diff&quot;,&#10;            &quot;elo_advantage&quot;, &quot;surface_elo_advantage&quot;,&#10;            &quot;elo_surface_interaction&quot;, &quot;elo_consistency&quot;,&#10;            &quot;rank_diff&quot;, &quot;rank_advantage&quot;, &quot;rank_ratio&quot;, &quot;elo_rank_mismatch&quot;,&#10;            &quot;elo_tier_winner&quot;, &quot;elo_tier_loser&quot;, &quot;tier_diff&quot;,&#10;            &quot;match_competitiveness&quot;, &quot;is_upset_potential&quot;,&#10;            &quot;h2h_count&quot;, &quot;h2h_balance&quot;&#10;        ]&#10;&#10;        # filtrar features disponibles&#10;        available_features = [col for col in feature_cols if col in df_train.columns]&#10;        df_train = fillna_features(df_train, available_features)&#10;&#10;        X_train = df_train[available_features]&#10;        y_train = df_train[&quot;target&quot;]&#10;&#10;        model, _ = train_model(X_train, y_train)&#10;&#10;        # guardar modelo&#10;        os.makedirs(os.path.dirname(model_path), exist_ok=True)&#10;        with open(model_path, 'wb') as f:&#10;            pickle.dump(model, f)&#10;&#10;        return model, available_features&#10;&#10;def predict_match_winner(df_match, model, feature_cols):&#10;    &quot;&quot;&quot;predice el ganador de un partido específico&quot;&quot;&quot;&#10;&#10;    # generar features&#10;    df_processed = clean_data(df_match.copy())&#10;    df_features = add_all_features(df_processed)&#10;&#10;    # crear ambas versiones del partido (A vs B y B vs A)&#10;    df_balanced = make_dual_rows(df_features)&#10;    df_balanced = fillna_features(df_balanced, feature_cols)&#10;&#10;    # solo usar la primera fila (player1 como ganador)&#10;    X = df_balanced.iloc[[0]][feature_cols]&#10;&#10;    # predecir probabilidad&#10;    prob = model.predict_proba(X)[0][1]  # probabilidad de que player1 gane&#10;&#10;    # determinar ganador&#10;    if prob &gt; 0.5:&#10;        winner = df_match.iloc[0][&quot;winner_name&quot;]&#10;        loser = df_match.iloc[0][&quot;loser_name&quot;]&#10;        confidence = prob&#10;    else:&#10;        winner = df_match.iloc[0][&quot;loser_name&quot;]&#10;        loser = df_match.iloc[0][&quot;winner_name&quot;]&#10;        confidence = 1 - prob&#10;&#10;    return winner, loser, confidence&#10;&#10;def predict_match_winner_with_history(df_match, model, feature_cols,&#10;                                    current_elos, current_surface_elos, current_h2h):&#10;    &quot;&quot;&quot;predice el ganador usando elos y h2h históricos actualizados&quot;&quot;&quot;&#10;&#10;    # obtener nombres de jugadores&#10;    player1 = df_match.iloc[0][&quot;winner_name&quot;]&#10;    player2 = df_match.iloc[0][&quot;loser_name&quot;]&#10;    surface = df_match.iloc[0][&quot;surface&quot;]&#10;&#10;    # obtener elos actuales (o por defecto si es jugador nuevo)&#10;    elo1 = current_elos.get(player1, 1500)&#10;    elo2 = current_elos.get(player2, 1500)&#10;&#10;    surface_elo1 = current_surface_elos.get(f&quot;{player1}_{surface}&quot;, 1500)&#10;    surface_elo2 = current_surface_elos.get(f&quot;{player2}_{surface}&quot;, 1500)&#10;&#10;    # obtener h2h actual&#10;    pair = tuple(sorted([player1, player2]))&#10;    h2h_data = current_h2h[pair]&#10;&#10;    # probar ambas configuraciones: player1 como ganador Y player2 como ganador&#10;    # y elegir la que tenga mayor probabilidad&#10;&#10;    configs = [&#10;        {&#10;            &quot;winner&quot;: player1, &quot;loser&quot;: player2,&#10;            &quot;elo_winner&quot;: elo1, &quot;elo_loser&quot;: elo2,&#10;            &quot;surface_elo_winner&quot;: surface_elo1, &quot;surface_elo_loser&quot;: surface_elo2&#10;        },&#10;        {&#10;            &quot;winner&quot;: player2, &quot;loser&quot;: player1,&#10;            &quot;elo_winner&quot;: elo2, &quot;elo_loser&quot;: elo1,&#10;            &quot;surface_elo_winner&quot;: surface_elo2, &quot;surface_elo_loser&quot;: surface_elo1&#10;        }&#10;    ]&#10;&#10;    best_prob = 0&#10;    best_winner = None&#10;    best_loser = None&#10;&#10;    for config in configs:&#10;        # calcular features para esta configuración&#10;        features_dict = {&#10;            &quot;elo_winner&quot;: config[&quot;elo_winner&quot;],&#10;            &quot;elo_loser&quot;: config[&quot;elo_loser&quot;],&#10;            &quot;elo_diff&quot;: config[&quot;elo_winner&quot;] - config[&quot;elo_loser&quot;],&#10;            &quot;surface_elo_winner&quot;: config[&quot;surface_elo_winner&quot;],&#10;            &quot;surface_elo_loser&quot;: config[&quot;surface_elo_loser&quot;],&#10;            &quot;surface_elo_diff&quot;: config[&quot;surface_elo_winner&quot;] - config[&quot;surface_elo_loser&quot;],&#10;        }&#10;&#10;        # features categóricas&#10;        elo_diff = config[&quot;elo_winner&quot;] - config[&quot;elo_loser&quot;]&#10;        features_dict[&quot;elo_advantage&quot;] = (2 if elo_diff &gt; 200 else&#10;                                        (1 if elo_diff &gt; 50 else&#10;                                        (-1 if elo_diff &lt; -50 else&#10;                                        (-2 if elo_diff &lt; -200 else 0))))&#10;&#10;        surface_elo_diff = config[&quot;surface_elo_winner&quot;] - config[&quot;surface_elo_loser&quot;]&#10;        features_dict[&quot;surface_elo_advantage&quot;] = (2 if surface_elo_diff &gt; 200 else&#10;                                                (1 if surface_elo_diff &gt; 50 else&#10;                                                (-1 if surface_elo_diff &lt; -50 else&#10;                                                (-2 if surface_elo_diff &lt; -200 else 0))))&#10;&#10;        # features de interacción&#10;        features_dict[&quot;elo_surface_interaction&quot;] = elo_diff * surface_elo_diff / 10000&#10;        features_dict[&quot;elo_consistency&quot;] = abs(elo_diff - surface_elo_diff)&#10;&#10;        # features de ranking (usar valores por defecto)&#10;        features_dict.update({&#10;            &quot;rank_diff&quot;: 0,&#10;            &quot;rank_advantage&quot;: 0,&#10;            &quot;rank_ratio&quot;: 1,&#10;            &quot;elo_rank_mismatch&quot;: 0&#10;        })&#10;&#10;        # features de tiers&#10;        def get_tier(elo):&#10;            if elo &lt; 1400: return 0&#10;            elif elo &lt; 1600: return 1&#10;            elif elo &lt; 1800: return 2&#10;            elif elo &lt; 2000: return 3&#10;            else: return 4&#10;&#10;        tier_winner = get_tier(config[&quot;elo_winner&quot;])&#10;        tier_loser = get_tier(config[&quot;elo_loser&quot;])&#10;        features_dict.update({&#10;            &quot;elo_tier_winner&quot;: tier_winner,&#10;            &quot;elo_tier_loser&quot;: tier_loser,&#10;            &quot;tier_diff&quot;: tier_winner - tier_loser&#10;        })&#10;&#10;        # features de competitividad&#10;        features_dict[&quot;match_competitiveness&quot;] = 1 / (1 + abs(elo_diff) / 100)&#10;        features_dict[&quot;is_upset_potential&quot;] = int(abs(elo_diff) &gt; 150)&#10;&#10;        # features h2h logarítmicas&#10;        h2h_count = h2h_data[&quot;count&quot;]&#10;        features_dict[&quot;h2h_count&quot;] = np.log1p(h2h_count)&#10;&#10;        if h2h_count == 0:&#10;            features_dict[&quot;h2h_balance&quot;] = 0&#10;        else:&#10;            winner_wins = h2h_data[&quot;winner_wins&quot;]&#10;            loser_wins = h2h_count - winner_wins&#10;&#10;            # determinar quién es quién en el historial&#10;            if config[&quot;winner&quot;] == min(pair):  # winner es el primero alfabéticamente&#10;                w_wins = winner_wins&#10;                l_wins = loser_wins&#10;            else:&#10;                w_wins = loser_wins&#10;                l_wins = winner_wins&#10;&#10;            features_dict[&quot;h2h_balance&quot;] = np.log1p(w_wins) - np.log1p(l_wins)&#10;&#10;        # crear dataframe con las features&#10;        feature_values = [features_dict.get(col, 0) for col in feature_cols]&#10;        X = pd.DataFrame([feature_values], columns=feature_cols)&#10;&#10;        # predecir probabilidad&#10;        prob = model.predict_proba(X)[0][1]&#10;&#10;        # si esta configuración es mejor, guardarla&#10;        if prob &gt; best_prob:&#10;            best_prob = prob&#10;            best_winner = config[&quot;winner&quot;]&#10;            best_loser = config[&quot;loser&quot;]&#10;&#10;    return best_winner, best_loser, best_prob&#10;&#10;def simulate_tournament_round(matches_df, model, feature_cols, round_name):&#10;    &quot;&quot;&quot;simula una ronda completa del torneo&quot;&quot;&quot;&#10;&#10;    print(f&quot;\n--- simulando {round_name} ---&quot;)&#10;    winners = []&#10;    results = []&#10;&#10;    for i, (_, match) in enumerate(matches_df.iterrows()):&#10;        # crear dataframe de un solo partido&#10;        match_df = pd.DataFrame([match])&#10;&#10;        # predecir ganador&#10;        winner, loser, confidence = predict_match_winner(match_df, model, feature_cols)&#10;&#10;        winners.append(winner)&#10;        result = {&#10;            &quot;round&quot;: round_name,&#10;            &quot;match&quot;: f&quot;{match['winner_name']} vs {match['loser_name']}&quot;,&#10;            &quot;winner&quot;: winner,&#10;            &quot;loser&quot;: loser,&#10;            &quot;confidence&quot;: confidence&#10;        }&#10;        results.append(result)&#10;&#10;        print(f&quot;  {match['winner_name']} vs {match['loser_name']} → {winner} ({confidence:.3f})&quot;)&#10;&#10;    return winners, results&#10;&#10;def simulate_tournament_round_with_history(matches_df, model, feature_cols, round_name,&#10;                                         current_elos, current_surface_elos, current_h2h):&#10;    &quot;&quot;&quot;simula una ronda completa usando historial actualizado&quot;&quot;&quot;&#10;&#10;    print(f&quot;\n--- simulando {round_name} ---&quot;)&#10;    winners = []&#10;    results = []&#10;&#10;    for i, (_, match) in enumerate(matches_df.iterrows()):&#10;        # crear dataframe de un solo partido&#10;        match_df = pd.DataFrame([match])&#10;&#10;        # obtener elos actuales para mostrar&#10;        player1 = match['winner_name']&#10;        player2 = match['loser_name']&#10;        elo1 = current_elos.get(player1, 1500)&#10;        elo2 = current_elos.get(player2, 1500)&#10;&#10;        # predecir ganador usando historial&#10;        winner, loser, confidence = predict_match_winner_with_history(&#10;            match_df, model, feature_cols, current_elos, current_surface_elos, current_h2h&#10;        )&#10;&#10;        winners.append(winner)&#10;        result = {&#10;            &quot;round&quot;: round_name,&#10;            &quot;match&quot;: f&quot;{player1} vs {player2}&quot;,&#10;            &quot;winner&quot;: winner,&#10;            &quot;loser&quot;: loser,&#10;            &quot;confidence&quot;: confidence,&#10;            &quot;elo_player1&quot;: elo1,&#10;            &quot;elo_player2&quot;: elo2&#10;        }&#10;        results.append(result)&#10;&#10;        # actualizar elos y h2h después del partido&#10;        surface = match[&quot;surface&quot;]&#10;        update_elos_after_match(winner, loser, surface, current_elos, current_surface_elos)&#10;        update_h2h_after_match(winner, loser, current_h2h)&#10;&#10;        print(f&quot;  {player1} ({elo1:.0f}) vs {player2} ({elo2:.0f}) → {winner} ({confidence:.3f})&quot;)&#10;&#10;    return winners, results&#10;&#10;def create_next_round_matches(winners, round_name):&#10;    &quot;&quot;&quot;crea los emparejamientos de la siguiente ronda&quot;&quot;&quot;&#10;&#10;    if len(winners) % 2 != 0:&#10;        raise ValueError(f&quot;número impar de ganadores: {len(winners)}&quot;)&#10;&#10;    matches = []&#10;    for i in range(0, len(winners), 2):&#10;        match = {&#10;            &quot;tourney_id&quot;: &quot;2025-AO&quot;,&#10;            &quot;tourney_name&quot;: &quot;Australian Open&quot;,&#10;            &quot;surface&quot;: &quot;Hard&quot;,&#10;            &quot;draw_size&quot;: 128,&#10;            &quot;tourney_level&quot;: &quot;G&quot;,&#10;            &quot;tourney_date&quot;: 20250113,&#10;            &quot;match_num&quot;: i//2 + 1,&#10;            &quot;winner_name&quot;: winners[i],&#10;            &quot;loser_name&quot;: winners[i+1],&#10;            &quot;round&quot;: round_name,&#10;            &quot;best_of&quot;: 5&#10;        }&#10;&#10;        # columnas requeridas con valores por defecto&#10;        for col in [&quot;winner_id&quot;, &quot;winner_seed&quot;, &quot;winner_hand&quot;, &quot;winner_ht&quot;, &quot;winner_ioc&quot;, &quot;winner_age&quot;,&#10;                   &quot;loser_id&quot;, &quot;loser_seed&quot;, &quot;loser_hand&quot;, &quot;loser_ht&quot;, &quot;loser_ioc&quot;, &quot;loser_age&quot;,&#10;                   &quot;w_ace&quot;, &quot;w_df&quot;, &quot;w_svpt&quot;, &quot;w_1stIn&quot;, &quot;w_1stWon&quot;, &quot;w_2ndWon&quot;, &quot;w_SvGms&quot;, &quot;w_bpSaved&quot;, &quot;w_bpFaced&quot;,&#10;                   &quot;l_ace&quot;, &quot;l_df&quot;, &quot;l_svpt&quot;, &quot;l_1stIn&quot;, &quot;l_1stWon&quot;, &quot;l_2ndWon&quot;, &quot;l_SvGms&quot;, &quot;l_bpSaved&quot;, &quot;l_bpFaced&quot;,&#10;                   &quot;winner_rank&quot;, &quot;winner_rank_points&quot;, &quot;loser_rank&quot;, &quot;loser_rank_points&quot;, &quot;score&quot;, &quot;minutes&quot;]:&#10;            match[col] = None&#10;&#10;        matches.append(match)&#10;&#10;    return pd.DataFrame(matches)&#10;&#10;def update_elos_after_match(winner, loser, surface, current_elos, current_surface_elos, k=32):&#10;    &quot;&quot;&quot;actualiza los elos después de un partido&quot;&quot;&quot;&#10;&#10;    # elos actuales&#10;    elo_w = current_elos.get(winner, 1500)&#10;    elo_l = current_elos.get(loser, 1500)&#10;&#10;    surface_elo_w = current_surface_elos.get(f&quot;{winner}_{surface}&quot;, 1500)&#10;    surface_elo_l = current_surface_elos.get(f&quot;{loser}_{surface}&quot;, 1500)&#10;&#10;    # actualizar elo global&#10;    expected_w = 1 / (1 + 10 ** ((elo_l - elo_w) / 400))&#10;    current_elos[winner] = elo_w + k * (1 - expected_w)&#10;    current_elos[loser] = elo_l + k * (0 - (1 - expected_w))&#10;&#10;    # actualizar elo de superficie&#10;    surface_expected_w = 1 / (1 + 10 ** ((surface_elo_l - surface_elo_w) / 400))&#10;    current_surface_elos[f&quot;{winner}_{surface}&quot;] = surface_elo_w + k * (1 - surface_expected_w)&#10;    current_surface_elos[f&quot;{loser}_{surface}&quot;] = surface_elo_l + k * (0 - (1 - surface_expected_w))&#10;&#10;def update_h2h_after_match(winner, loser, current_h2h):&#10;    &quot;&quot;&quot;actualiza el historial h2h después de un partido&quot;&quot;&quot;&#10;    pair = tuple(sorted([winner, loser]))&#10;    current_h2h[pair][&quot;count&quot;] += 1&#10;&#10;    # incrementar victorias del ganador&#10;    if winner == min(pair):  # si el ganador es el primero alfabéticamente&#10;        current_h2h[pair][&quot;winner_wins&quot;] += 1&#10;&#10;def simulate_australian_open_2025():&#10;    &quot;&quot;&quot;simula el torneo completo del australian open 2025 usando datos históricos&quot;&quot;&quot;&#10;&#10;    print(&quot;=== simulador australian open 2025 con datos históricos ===&quot;)&#10;&#10;    # extraer elos y h2h históricos del dataset de entrenamiento&#10;    current_elos, current_surface_elos, current_h2h = extract_historical_elos_and_h2h()&#10;&#10;    # cargar modelo entrenado y obtener sus features exactas&#10;    model, feature_cols = load_trained_model()&#10;&#10;    print(f&quot;usando features del modelo: {feature_cols}&quot;)&#10;&#10;    # generar R32&#10;    r32_df = create_ao_2025_r32()&#10;&#10;    # simular cada ronda con historial actualizado&#10;    all_results = []&#10;&#10;    # R32 (32 → 16)&#10;    r16_winners, r32_results = simulate_tournament_round_with_history(&#10;        r32_df, model, feature_cols, &quot;R32&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(r32_results)&#10;&#10;    # R16 (16 → 8)&#10;    r16_df = create_next_round_matches(r16_winners, &quot;R16&quot;)&#10;    qf_winners, r16_results = simulate_tournament_round_with_history(&#10;        r16_df, model, feature_cols, &quot;R16&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(r16_results)&#10;&#10;    # cuartos de final (8 → 4)&#10;    qf_df = create_next_round_matches(qf_winners, &quot;QF&quot;)&#10;    sf_winners, qf_results = simulate_tournament_round_with_history(&#10;        qf_df, model, feature_cols, &quot;QF&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(qf_results)&#10;&#10;    # semifinales (4 → 2)&#10;    sf_df = create_next_round_matches(sf_winners, &quot;SF&quot;)&#10;    f_winners, sf_results = simulate_tournament_round_with_history(&#10;        sf_df, model, feature_cols, &quot;SF&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(sf_results)&#10;&#10;    # final (2 → 1)&#10;    f_df = create_next_round_matches(f_winners, &quot;F&quot;)&#10;    champion, f_results = simulate_tournament_round_with_history(&#10;        f_df, model, feature_cols, &quot;F&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(f_results)&#10;&#10;    # resultados finales&#10;    print(f&quot;\ncampeón australian open 2025: {champion[0]}&quot;)&#10;    print(f&quot;finalista: {f_results[0]['loser']}&quot;)&#10;    print(f&quot;semifinalistas: {', '.join([r['loser'] for r in sf_results])}&quot;)&#10;&#10;    # mostrar algunos elos finales de jugadores top&#10;    top_players = [&quot;Jannik Sinner&quot;, &quot;Novak Djokovic&quot;, &quot;Carlos Alcaraz&quot;, &quot;Daniil Medvedev&quot;]&#10;    print(f&quot;\nelos finales después del torneo:&quot;)&#10;    for player in top_players:&#10;        if player in current_elos:&#10;            print(f&quot;  {player}: {current_elos[player]:.0f}&quot;)&#10;&#10;    # guardar resultados&#10;    results_df = pd.DataFrame(all_results)&#10;    output_path = os.path.join(BASE_DIR, &quot;outputs&quot;, &quot;australian_open_2025_results.csv&quot;)&#10;    os.makedirs(os.path.dirname(output_path), exist_ok=True)&#10;    results_df.to_csv(output_path, index=False)&#10;&#10;    print(f&quot;\nresultados guardados en: {output_path}&quot;)&#10;&#10;    return results_df, champion[0]&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    results, champion = simulate_australian_open_2025()&#10;    print(f&quot;\n simulación completada - campeón: {champion}&quot;)&#10;" />
              <option name="updatedContent" value="# src/australian_open_2025_simulator.py&#10;&#10;import pandas as pd&#10;import numpy as np&#10;import os&#10;from data_loader import BASE_DIR, load_train_data&#10;from preprocess import clean_data&#10;from features import add_all_features, compute_elo_ratings, compute_surface_elo, compute_h2h&#10;from utils import make_dual_rows, fillna_features&#10;from model import train_model&#10;import pickle&#10;from collections import defaultdict&#10;&#10;# simulador completo del australian open 2025 que usa datos históricos&#10;&#10;def extract_historical_elos_and_h2h():&#10;    &quot;&quot;&quot;extrae los elos finales y historial h2h de todos los datos de entrenamiento&quot;&quot;&quot;&#10;    print(&quot;extrayendo elos y h2h históricos...&quot;)&#10;&#10;    # cargar todos los datos históricos&#10;    df_historical = load_train_data()&#10;    df_historical = clean_data(df_historical)&#10;&#10;    # calcular elos progresivamente en todo el dataset histórico&#10;    df_with_features = add_all_features(df_historical)&#10;&#10;    # extraer elos finales de cada jugador&#10;    final_elos = {}&#10;    final_surface_elos = {}&#10;&#10;    # obtener el último elo de cada jugador&#10;    for _, row in df_with_features.iterrows():&#10;        winner = row[&quot;winner_name&quot;]&#10;        loser = row[&quot;loser_name&quot;]&#10;&#10;        final_elos[winner] = row[&quot;elo_winner&quot;]&#10;        final_elos[loser] = row[&quot;elo_loser&quot;]&#10;&#10;        # elos de superficie&#10;        surface = row.get(&quot;surface&quot;, &quot;Hard&quot;)&#10;        final_surface_elos[f&quot;{winner}_{surface}&quot;] = row[&quot;surface_elo_winner&quot;]&#10;        final_surface_elos[f&quot;{loser}_{surface}&quot;] = row[&quot;surface_elo_loser&quot;]&#10;&#10;    # extraer historial h2h completo&#10;    h2h_history = defaultdict(lambda: {&quot;count&quot;: 0, &quot;winner_wins&quot;: 0})&#10;&#10;    for _, row in df_historical.iterrows():&#10;        winner = row[&quot;winner_name&quot;]&#10;        loser = row[&quot;loser_name&quot;]&#10;        pair = tuple(sorted([winner, loser]))&#10;&#10;        h2h_history[pair][&quot;count&quot;] += 1&#10;        # contar victorias del ganador&#10;        if winner == min(pair):  # si el ganador es el primero alfabéticamente&#10;            h2h_history[pair][&quot;winner_wins&quot;] += 1&#10;&#10;    print(f&quot;elos extraídos: {len(final_elos)} jugadores&quot;)&#10;    print(f&quot;h2h extraído: {len(h2h_history)} pares&quot;)&#10;&#10;    return final_elos, final_surface_elos, h2h_history&#10;&#10;def create_ao_2025_r32():&#10;    &quot;&quot;&quot;crea el dataframe base con los partidos de R32 del australian open 2025&quot;&quot;&quot;&#10;&#10;    # emparejamientos reales de la R32 (puedes actualizar con los datos reales)&#10;    r32_matches = [&#10;        # cuarto superior&#10;        {&quot;player1&quot;: &quot;Jannik Sinner&quot;, &quot;player2&quot;: &quot;Nicolas Jarry&quot;},&#10;        {&quot;player1&quot;: &quot;Daniil Medvedev&quot;, &quot;player2&quot;: &quot;Learner Tien&quot;},&#10;        {&quot;player1&quot;: &quot;Alexander Zverev&quot;, &quot;player2&quot;: &quot;Ugo Humbert&quot;},&#10;        {&quot;player1&quot;: &quot;Carlos Alcaraz&quot;, &quot;player2&quot;: &quot;Jack Draper&quot;},&#10;        {&quot;player1&quot;: &quot;Tommy Paul&quot;, &quot;player2&quot;: &quot;Alejandro Davidovich Fokina&quot;},&#10;        {&quot;player1&quot;: &quot;Ben Shelton&quot;, &quot;player2&quot;: &quot;Lorenzo Musetti&quot;},&#10;        {&quot;player1&quot;: &quot;Novak Djokovic&quot;, &quot;player2&quot;: &quot;Jiri Lehecka&quot;},&#10;        {&quot;player1&quot;: &quot;Taylor Fritz&quot;, &quot;player2&quot;: &quot;Gael Monfils&quot;},&#10;&#10;        # cuarto medio-superior&#10;        {&quot;player1&quot;: &quot;Casper Ruud&quot;, &quot;player2&quot;: &quot;Jenson Brooksby&quot;},&#10;        {&quot;player1&quot;: &quot;Alex de Minaur&quot;, &quot;player2&quot;: &quot;Alex Michelsen&quot;},&#10;        {&quot;player1&quot;: &quot;Stefanos Tsitsipas&quot;, &quot;player2&quot;: &quot;Thanasi Kokkinakis&quot;},&#10;        {&quot;player1&quot;: &quot;Sebastian Korda&quot;, &quot;player2&quot;: &quot;Corentin Moutet&quot;},&#10;        {&quot;player1&quot;: &quot;Hubert Hurkacz&quot;, &quot;player2&quot;: &quot;Arthur Fils&quot;},&#10;        {&quot;player1&quot;: &quot;Frances Tiafoe&quot;, &quot;player2&quot;: &quot;Fabian Marozsan&quot;},&#10;        {&quot;player1&quot;: &quot;Grigor Dimitrov&quot;, &quot;player2&quot;: &quot;Rinky Hijikata&quot;},&#10;        {&quot;player1&quot;: &quot;Andrey Rublev&quot;, &quot;player2&quot;: &quot;Jakub Mensik&quot;},&#10;&#10;        # cuarto medio-inferior&#10;        {&quot;player1&quot;: &quot;Holger Rune&quot;, &quot;player2&quot;: &quot;Matteo Berrettini&quot;},&#10;        {&quot;player1&quot;: &quot;Lorenzo Sonego&quot;, &quot;player2&quot;: &quot;Facundo Diaz Acosta&quot;},&#10;        {&quot;player1&quot;: &quot;Felix Auger-Aliassime&quot;, &quot;player2&quot;: &quot;Botic van de Zandschulp&quot;},&#10;        {&quot;player1&quot;: &quot;Karen Khachanov&quot;, &quot;player2&quot;: &quot;Giovanni Mpetshi Perricard&quot;},&#10;        {&quot;player1&quot;: &quot;Sebastian Baez&quot;, &quot;player2&quot;: &quot;Pavel Kotov&quot;},&#10;        {&quot;player1&quot;: &quot;Jordan Thompson&quot;, &quot;player2&quot;: &quot;Adrian Mannarino&quot;},&#10;        {&quot;player1&quot;: &quot;Francisco Cerundolo&quot;, &quot;player2&quot;: &quot;Tomas Martin Etcheverry&quot;},&#10;        {&quot;player1&quot;: &quot;Flavio Cobolli&quot;, &quot;player2&quot;: &quot;James Duckworth&quot;},&#10;&#10;        # cuarto inferior&#10;        {&quot;player1&quot;: &quot;Alexei Popyrin&quot;, &quot;player2&quot;: &quot;Marcos Giron&quot;},&#10;        {&quot;player1&quot;: &quot;Matteo Arnaldi&quot;, &quot;player2&quot;: &quot;Zhang Yifan&quot;},&#10;        {&quot;player1&quot;: &quot;Cameron Norrie&quot;, &quot;player2&quot;: &quot;Yoshihito Nishioka&quot;},&#10;        {&quot;player1&quot;: &quot;Alexander Bublik&quot;, &quot;player2&quot;: &quot;Brandon Nakashima&quot;},&#10;        {&quot;player1&quot;: &quot;Arthur Cazaux&quot;, &quot;player2&quot;: &quot;Nuno Borges&quot;},&#10;        {&quot;player1&quot;: &quot;Daniel Evans&quot;, &quot;player2&quot;: &quot;Quentin Halys&quot;},&#10;        {&quot;player1&quot;: &quot;Roman Safiullin&quot;, &quot;player2&quot;: &quot;Roberto Carballes Baena&quot;},&#10;        {&quot;player1&quot;: &quot;Mariano Navone&quot;, &quot;player2&quot;: &quot;Christopher O'Connell&quot;}&#10;    ]&#10;&#10;    # crear dataframe base&#10;    matches = []&#10;    for i, match in enumerate(r32_matches):&#10;        # crear fila base para cada partido&#10;        row = {&#10;            &quot;tourney_id&quot;: &quot;2025-AO&quot;,&#10;            &quot;tourney_name&quot;: &quot;Australian Open&quot;,&#10;            &quot;surface&quot;: &quot;Hard&quot;,&#10;            &quot;draw_size&quot;: 128,&#10;            &quot;tourney_level&quot;: &quot;G&quot;,&#10;            &quot;tourney_date&quot;: 20250113,  # fecha estimada&#10;            &quot;match_num&quot;: i + 1,&#10;            &quot;winner_name&quot;: match[&quot;player1&quot;],  # placeholder, se determinará por predicción&#10;            &quot;loser_name&quot;: match[&quot;player2&quot;],   # placeholder&#10;            &quot;round&quot;: &quot;R32&quot;,&#10;            &quot;best_of&quot;: 5,&#10;            &quot;score&quot;: None,&#10;            &quot;minutes&quot;: None&#10;        }&#10;&#10;        # columnas requeridas con valores por defecto&#10;        for col in [&quot;winner_id&quot;, &quot;winner_seed&quot;, &quot;winner_hand&quot;, &quot;winner_ht&quot;, &quot;winner_ioc&quot;, &quot;winner_age&quot;,&#10;                   &quot;loser_id&quot;, &quot;loser_seed&quot;, &quot;loser_hand&quot;, &quot;loser_ht&quot;, &quot;loser_ioc&quot;, &quot;loser_age&quot;,&#10;                   &quot;w_ace&quot;, &quot;w_df&quot;, &quot;w_svpt&quot;, &quot;w_1stIn&quot;, &quot;w_1stWon&quot;, &quot;w_2ndWon&quot;, &quot;w_SvGms&quot;, &quot;w_bpSaved&quot;, &quot;w_bpFaced&quot;,&#10;                   &quot;l_ace&quot;, &quot;l_df&quot;, &quot;l_svpt&quot;, &quot;l_1stIn&quot;, &quot;l_1stWon&quot;, &quot;l_2ndWon&quot;, &quot;l_SvGms&quot;, &quot;l_bpSaved&quot;, &quot;l_bpFaced&quot;,&#10;                   &quot;winner_rank&quot;, &quot;winner_rank_points&quot;, &quot;loser_rank&quot;, &quot;loser_rank_points&quot;]:&#10;            row[col] = None&#10;&#10;        matches.append(row)&#10;&#10;    return pd.DataFrame(matches)&#10;&#10;def load_trained_model():&#10;    &quot;&quot;&quot;carga el modelo entrenado o entrena uno nuevo&quot;&quot;&quot;&#10;    model_path = os.path.join(BASE_DIR, &quot;outputs&quot;, &quot;trained_model.pkl&quot;)&#10;&#10;    if os.path.exists(model_path):&#10;        print(&quot;cargando modelo preentrenado...&quot;)&#10;        with open(model_path, 'rb') as f:&#10;            model = pickle.load(f)&#10;&#10;        # obtener las features exactas que usa el modelo&#10;        if hasattr(model, 'feature_names_in_'):&#10;            model_features = list(model.feature_names_in_)&#10;            print(f&quot;modelo entrenado con features: {model_features}&quot;)&#10;            return model, model_features&#10;        else:&#10;            # fallback a features por defecto&#10;            default_features = [&#10;                &quot;elo_winner&quot;, &quot;elo_loser&quot;, &quot;elo_diff&quot;,&#10;                &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;, &quot;surface_elo_diff&quot;,&#10;                &quot;elo_advantage&quot;, &quot;surface_elo_advantage&quot;,&#10;                &quot;rank_diff&quot;, &quot;rank_advantage&quot;, &quot;rank_ratio&quot;, &quot;elo_rank_mismatch&quot;,&#10;                &quot;elo_tier_winner&quot;, &quot;elo_tier_loser&quot;, &quot;tier_diff&quot;,&#10;                &quot;match_competitiveness&quot;, &quot;is_upset_potential&quot;,&#10;                &quot;h2h_count&quot;, &quot;h2h_balance&quot;&#10;            ]&#10;            return model, default_features&#10;    else:&#10;        print(&quot;entrenando nuevo modelo...&quot;)&#10;        # cargar datos de entrenamiento&#10;        features_train_path = os.path.join(BASE_DIR, &quot;data&quot;, &quot;processed&quot;, &quot;features_train.csv&quot;)&#10;        df_train = pd.read_csv(features_train_path)&#10;        df_train = make_dual_rows(df_train)&#10;&#10;        feature_cols = [&#10;            &quot;elo_winner&quot;, &quot;elo_loser&quot;, &quot;elo_diff&quot;,&#10;            &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;, &quot;surface_elo_diff&quot;,&#10;            &quot;elo_advantage&quot;, &quot;surface_elo_advantage&quot;,&#10;            &quot;elo_surface_interaction&quot;, &quot;elo_consistency&quot;,&#10;            &quot;rank_diff&quot;, &quot;rank_advantage&quot;, &quot;rank_ratio&quot;, &quot;elo_rank_mismatch&quot;,&#10;            &quot;elo_tier_winner&quot;, &quot;elo_tier_loser&quot;, &quot;tier_diff&quot;,&#10;            &quot;match_competitiveness&quot;, &quot;is_upset_potential&quot;,&#10;            &quot;h2h_count&quot;, &quot;h2h_balance&quot;&#10;        ]&#10;&#10;        # filtrar features disponibles&#10;        available_features = [col for col in feature_cols if col in df_train.columns]&#10;        df_train = fillna_features(df_train, available_features)&#10;&#10;        X_train = df_train[available_features]&#10;        y_train = df_train[&quot;target&quot;]&#10;&#10;        model, _ = train_model(X_train, y_train)&#10;&#10;        # guardar modelo&#10;        os.makedirs(os.path.dirname(model_path), exist_ok=True)&#10;        with open(model_path, 'wb') as f:&#10;            pickle.dump(model, f)&#10;&#10;        return model, available_features&#10;&#10;def predict_match_winner(df_match, model, feature_cols):&#10;    &quot;&quot;&quot;predice el ganador de un partido específico&quot;&quot;&quot;&#10;&#10;    # generar features&#10;    df_processed = clean_data(df_match.copy())&#10;    df_features = add_all_features(df_processed)&#10;&#10;    # crear ambas versiones del partido (A vs B y B vs A)&#10;    df_balanced = make_dual_rows(df_features)&#10;    df_balanced = fillna_features(df_balanced, feature_cols)&#10;&#10;    # solo usar la primera fila (player1 como ganador)&#10;    X = df_balanced.iloc[[0]][feature_cols]&#10;&#10;    # predecir probabilidad&#10;    prob = model.predict_proba(X)[0][1]  # probabilidad de que player1 gane&#10;&#10;    # determinar ganador&#10;    if prob &gt; 0.5:&#10;        winner = df_match.iloc[0][&quot;winner_name&quot;]&#10;        loser = df_match.iloc[0][&quot;loser_name&quot;]&#10;        confidence = prob&#10;    else:&#10;        winner = df_match.iloc[0][&quot;loser_name&quot;]&#10;        loser = df_match.iloc[0][&quot;winner_name&quot;]&#10;        confidence = 1 - prob&#10;&#10;    return winner, loser, confidence&#10;&#10;def predict_match_winner_with_history(df_match, model, feature_cols,&#10;                                    current_elos, current_surface_elos, current_h2h):&#10;    &quot;&quot;&quot;predice el ganador usando elos y h2h históricos actualizados&quot;&quot;&quot;&#10;&#10;    # obtener nombres de jugadores&#10;    player1 = df_match.iloc[0][&quot;winner_name&quot;]&#10;    player2 = df_match.iloc[0][&quot;loser_name&quot;]&#10;    surface = df_match.iloc[0][&quot;surface&quot;]&#10;&#10;    # obtener elos actuales (o por defecto si es jugador nuevo)&#10;    elo1 = current_elos.get(player1, 1500)&#10;    elo2 = current_elos.get(player2, 1500)&#10;&#10;    surface_elo1 = current_surface_elos.get(f&quot;{player1}_{surface}&quot;, 1500)&#10;    surface_elo2 = current_surface_elos.get(f&quot;{player2}_{surface}&quot;, 1500)&#10;&#10;    # obtener h2h actual&#10;    pair = tuple(sorted([player1, player2]))&#10;    h2h_data = current_h2h[pair]&#10;&#10;    # calcular features manualmente para player1 como ganador&#10;    features_dict = {&#10;        &quot;elo_winner&quot;: elo1,&#10;        &quot;elo_loser&quot;: elo2,&#10;        &quot;elo_diff&quot;: elo1 - elo2,&#10;        &quot;surface_elo_winner&quot;: surface_elo1,&#10;        &quot;surface_elo_loser&quot;: surface_elo2,&#10;        &quot;surface_elo_diff&quot;: surface_elo1 - surface_elo2,&#10;    }&#10;&#10;    # features categóricas&#10;    elo_diff = elo1 - elo2&#10;    features_dict[&quot;elo_advantage&quot;] = (2 if elo_diff &gt; 200 else&#10;                                    (1 if elo_diff &gt; 50 else&#10;                                    (-1 if elo_diff &lt; -50 else&#10;                                    (-2 if elo_diff &lt; -200 else 0))))&#10;&#10;    surface_elo_diff = surface_elo1 - surface_elo2&#10;    features_dict[&quot;surface_elo_advantage&quot;] = (2 if surface_elo_diff &gt; 200 else&#10;                                            (1 if surface_elo_diff &gt; 50 else&#10;                                            (-1 if surface_elo_diff &lt; -50 else&#10;                                            (-2 if surface_elo_diff &lt; -200 else 0))))&#10;&#10;    # features de interacción&#10;    features_dict[&quot;elo_surface_interaction&quot;] = elo_diff * surface_elo_diff / 10000&#10;    features_dict[&quot;elo_consistency&quot;] = abs(elo_diff - surface_elo_diff)&#10;&#10;    # features de ranking (usar valores por defecto)&#10;    features_dict.update({&#10;        &quot;rank_diff&quot;: 0,&#10;        &quot;rank_advantage&quot;: 0,&#10;        &quot;rank_ratio&quot;: 1,&#10;        &quot;elo_rank_mismatch&quot;: 0&#10;    })&#10;&#10;    # features de tiers&#10;    def get_tier(elo):&#10;        if elo &lt; 1400: return 0&#10;        elif elo &lt; 1600: return 1&#10;        elif elo &lt; 1800: return 2&#10;        elif elo &lt; 2000: return 3&#10;        else: return 4&#10;&#10;    tier1 = get_tier(elo1)&#10;    tier2 = get_tier(elo2)&#10;    features_dict.update({&#10;        &quot;elo_tier_winner&quot;: tier1,&#10;        &quot;elo_tier_loser&quot;: tier2,&#10;        &quot;tier_diff&quot;: tier1 - tier2&#10;    })&#10;&#10;    # features de competitividad&#10;    features_dict[&quot;match_competitiveness&quot;] = 1 / (1 + abs(elo_diff) / 100)&#10;    features_dict[&quot;is_upset_potential&quot;] = int(abs(elo_diff) &gt; 150)&#10;&#10;    # features h2h logarítmicas&#10;    h2h_count = h2h_data[&quot;count&quot;]&#10;    features_dict[&quot;h2h_count&quot;] = np.log1p(h2h_count)&#10;&#10;    if h2h_count == 0:&#10;        features_dict[&quot;h2h_balance&quot;] = 0&#10;    else:&#10;        winner_wins = h2h_data[&quot;winner_wins&quot;]&#10;        loser_wins = h2h_count - winner_wins&#10;&#10;        # determinar quién es quién en el historial&#10;        if player1 == min(pair):  # player1 es el primero alfabéticamente&#10;            p1_wins = winner_wins&#10;            p2_wins = loser_wins&#10;        else:&#10;            p1_wins = loser_wins&#10;            p2_wins = winner_wins&#10;&#10;        features_dict[&quot;h2h_balance&quot;] = np.log1p(p1_wins) - np.log1p(p2_wins)&#10;&#10;    # crear dataframe con las features y predecir&#10;    feature_values = [features_dict.get(col, 0) for col in feature_cols]&#10;    X = pd.DataFrame([feature_values], columns=feature_cols)&#10;&#10;    # predecir probabilidad de que player1 gane&#10;    prob_player1_wins = model.predict_proba(X)[0][1]&#10;    &#10;    # debug: imprimir información solo para algunos casos extremos&#10;    if prob_player1_wins &gt; 0.99 or prob_player1_wins &lt; 0.01:&#10;        print(f&quot;    DEBUG - {player1} ({elo1:.0f}) vs {player2} ({elo2:.0f})&quot;)&#10;        print(f&quot;    ELO diff: {elo_diff:.0f}, Surface ELO diff: {surface_elo_diff:.0f}&quot;)&#10;        print(f&quot;    ELO advantage: {features_dict['elo_advantage']}, Tier diff: {features_dict['tier_diff']}&quot;)&#10;        print(f&quot;    H2H count: {h2h_count}, H2H balance: {features_dict['h2h_balance']:.3f}&quot;)&#10;        print(f&quot;    Raw probability: {prob_player1_wins:.6f}&quot;)&#10;&#10;    # determinar ganador basado en probabilidad&#10;    if prob_player1_wins &gt; 0.5:&#10;        return player1, player2, prob_player1_wins&#10;    else:&#10;        return player2, player1, 1 - prob_player1_wins&#10;&#10;def simulate_tournament_round(matches_df, model, feature_cols, round_name):&#10;    &quot;&quot;&quot;simula una ronda completa del torneo&quot;&quot;&quot;&#10;&#10;    print(f&quot;\n--- simulando {round_name} ---&quot;)&#10;    winners = []&#10;    results = []&#10;&#10;    for i, (_, match) in enumerate(matches_df.iterrows()):&#10;        # crear dataframe de un solo partido&#10;        match_df = pd.DataFrame([match])&#10;&#10;        # predecir ganador&#10;        winner, loser, confidence = predict_match_winner(match_df, model, feature_cols)&#10;&#10;        winners.append(winner)&#10;        result = {&#10;            &quot;round&quot;: round_name,&#10;            &quot;match&quot;: f&quot;{match['winner_name']} vs {match['loser_name']}&quot;,&#10;            &quot;winner&quot;: winner,&#10;            &quot;loser&quot;: loser,&#10;            &quot;confidence&quot;: confidence&#10;        }&#10;        results.append(result)&#10;&#10;        print(f&quot;  {match['winner_name']} vs {match['loser_name']} → {winner} ({confidence:.3f})&quot;)&#10;&#10;    return winners, results&#10;&#10;def simulate_tournament_round_with_history(matches_df, model, feature_cols, round_name,&#10;                                         current_elos, current_surface_elos, current_h2h):&#10;    &quot;&quot;&quot;simula una ronda completa usando historial actualizado&quot;&quot;&quot;&#10;&#10;    print(f&quot;\n--- simulando {round_name} ---&quot;)&#10;    winners = []&#10;    results = []&#10;&#10;    for i, (_, match) in enumerate(matches_df.iterrows()):&#10;        # crear dataframe de un solo partido&#10;        match_df = pd.DataFrame([match])&#10;&#10;        # obtener elos actuales para mostrar&#10;        player1 = match['winner_name']&#10;        player2 = match['loser_name']&#10;        elo1 = current_elos.get(player1, 1500)&#10;        elo2 = current_elos.get(player2, 1500)&#10;&#10;        # predecir ganador usando historial&#10;        winner, loser, confidence = predict_match_winner_with_history(&#10;            match_df, model, feature_cols, current_elos, current_surface_elos, current_h2h&#10;        )&#10;&#10;        winners.append(winner)&#10;        result = {&#10;            &quot;round&quot;: round_name,&#10;            &quot;match&quot;: f&quot;{player1} vs {player2}&quot;,&#10;            &quot;winner&quot;: winner,&#10;            &quot;loser&quot;: loser,&#10;            &quot;confidence&quot;: confidence,&#10;            &quot;elo_player1&quot;: elo1,&#10;            &quot;elo_player2&quot;: elo2&#10;        }&#10;        results.append(result)&#10;&#10;        # actualizar elos y h2h después del partido&#10;        surface = match[&quot;surface&quot;]&#10;        update_elos_after_match(winner, loser, surface, current_elos, current_surface_elos)&#10;        update_h2h_after_match(winner, loser, current_h2h)&#10;&#10;        print(f&quot;  {player1} ({elo1:.0f}) vs {player2} ({elo2:.0f}) → {winner} ({confidence:.3f})&quot;)&#10;&#10;    return winners, results&#10;&#10;def create_next_round_matches(winners, round_name):&#10;    &quot;&quot;&quot;crea los emparejamientos de la siguiente ronda&quot;&quot;&quot;&#10;&#10;    if len(winners) % 2 != 0:&#10;        raise ValueError(f&quot;número impar de ganadores: {len(winners)}&quot;)&#10;&#10;    matches = []&#10;    for i in range(0, len(winners), 2):&#10;        match = {&#10;            &quot;tourney_id&quot;: &quot;2025-AO&quot;,&#10;            &quot;tourney_name&quot;: &quot;Australian Open&quot;,&#10;            &quot;surface&quot;: &quot;Hard&quot;,&#10;            &quot;draw_size&quot;: 128,&#10;            &quot;tourney_level&quot;: &quot;G&quot;,&#10;            &quot;tourney_date&quot;: 20250113,&#10;            &quot;match_num&quot;: i//2 + 1,&#10;            &quot;winner_name&quot;: winners[i],&#10;            &quot;loser_name&quot;: winners[i+1],&#10;            &quot;round&quot;: round_name,&#10;            &quot;best_of&quot;: 5&#10;        }&#10;&#10;        # columnas requeridas con valores por defecto&#10;        for col in [&quot;winner_id&quot;, &quot;winner_seed&quot;, &quot;winner_hand&quot;, &quot;winner_ht&quot;, &quot;winner_ioc&quot;, &quot;winner_age&quot;,&#10;                   &quot;loser_id&quot;, &quot;loser_seed&quot;, &quot;loser_hand&quot;, &quot;loser_ht&quot;, &quot;loser_ioc&quot;, &quot;loser_age&quot;,&#10;                   &quot;w_ace&quot;, &quot;w_df&quot;, &quot;w_svpt&quot;, &quot;w_1stIn&quot;, &quot;w_1stWon&quot;, &quot;w_2ndWon&quot;, &quot;w_SvGms&quot;, &quot;w_bpSaved&quot;, &quot;w_bpFaced&quot;,&#10;                   &quot;l_ace&quot;, &quot;l_df&quot;, &quot;l_svpt&quot;, &quot;l_1stIn&quot;, &quot;l_1stWon&quot;, &quot;l_2ndWon&quot;, &quot;l_SvGms&quot;, &quot;l_bpSaved&quot;, &quot;l_bpFaced&quot;,&#10;                   &quot;winner_rank&quot;, &quot;winner_rank_points&quot;, &quot;loser_rank&quot;, &quot;loser_rank_points&quot;, &quot;score&quot;, &quot;minutes&quot;]:&#10;            match[col] = None&#10;&#10;        matches.append(match)&#10;&#10;    return pd.DataFrame(matches)&#10;&#10;def update_elos_after_match(winner, loser, surface, current_elos, current_surface_elos, k=32):&#10;    &quot;&quot;&quot;actualiza los elos después de un partido&quot;&quot;&quot;&#10;&#10;    # elos actuales&#10;    elo_w = current_elos.get(winner, 1500)&#10;    elo_l = current_elos.get(loser, 1500)&#10;&#10;    surface_elo_w = current_surface_elos.get(f&quot;{winner}_{surface}&quot;, 1500)&#10;    surface_elo_l = current_surface_elos.get(f&quot;{loser}_{surface}&quot;, 1500)&#10;&#10;    # actualizar elo global&#10;    expected_w = 1 / (1 + 10 ** ((elo_l - elo_w) / 400))&#10;    current_elos[winner] = elo_w + k * (1 - expected_w)&#10;    current_elos[loser] = elo_l + k * (0 - (1 - expected_w))&#10;&#10;    # actualizar elo de superficie&#10;    surface_expected_w = 1 / (1 + 10 ** ((surface_elo_l - surface_elo_w) / 400))&#10;    current_surface_elos[f&quot;{winner}_{surface}&quot;] = surface_elo_w + k * (1 - surface_expected_w)&#10;    current_surface_elos[f&quot;{loser}_{surface}&quot;] = surface_elo_l + k * (0 - (1 - surface_expected_w))&#10;&#10;def update_h2h_after_match(winner, loser, current_h2h):&#10;    &quot;&quot;&quot;actualiza el historial h2h después de un partido&quot;&quot;&quot;&#10;    pair = tuple(sorted([winner, loser]))&#10;    current_h2h[pair][&quot;count&quot;] += 1&#10;&#10;    # incrementar victorias del ganador&#10;    if winner == min(pair):  # si el ganador es el primero alfabéticamente&#10;        current_h2h[pair][&quot;winner_wins&quot;] += 1&#10;&#10;def simulate_australian_open_2025():&#10;    &quot;&quot;&quot;simula el torneo completo del australian open 2025 usando datos históricos&quot;&quot;&quot;&#10;&#10;    print(&quot;=== simulador australian open 2025 con datos históricos ===&quot;)&#10;&#10;    # extraer elos y h2h históricos del dataset de entrenamiento&#10;    current_elos, current_surface_elos, current_h2h = extract_historical_elos_and_h2h()&#10;&#10;    # cargar modelo entrenado y obtener sus features exactas&#10;    model, feature_cols = load_trained_model()&#10;&#10;    print(f&quot;usando features del modelo: {feature_cols}&quot;)&#10;&#10;    # generar R32&#10;    r32_df = create_ao_2025_r32()&#10;&#10;    # simular cada ronda con historial actualizado&#10;    all_results = []&#10;&#10;    # R32 (32 → 16)&#10;    r16_winners, r32_results = simulate_tournament_round_with_history(&#10;        r32_df, model, feature_cols, &quot;R32&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(r32_results)&#10;&#10;    # R16 (16 → 8)&#10;    r16_df = create_next_round_matches(r16_winners, &quot;R16&quot;)&#10;    qf_winners, r16_results = simulate_tournament_round_with_history(&#10;        r16_df, model, feature_cols, &quot;R16&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(r16_results)&#10;&#10;    # cuartos de final (8 → 4)&#10;    qf_df = create_next_round_matches(qf_winners, &quot;QF&quot;)&#10;    sf_winners, qf_results = simulate_tournament_round_with_history(&#10;        qf_df, model, feature_cols, &quot;QF&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(qf_results)&#10;&#10;    # semifinales (4 → 2)&#10;    sf_df = create_next_round_matches(sf_winners, &quot;SF&quot;)&#10;    f_winners, sf_results = simulate_tournament_round_with_history(&#10;        sf_df, model, feature_cols, &quot;SF&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(sf_results)&#10;&#10;    # final (2 → 1)&#10;    f_df = create_next_round_matches(f_winners, &quot;F&quot;)&#10;    champion, f_results = simulate_tournament_round_with_history(&#10;        f_df, model, feature_cols, &quot;F&quot;, current_elos, current_surface_elos, current_h2h&#10;    )&#10;    all_results.extend(f_results)&#10;&#10;    # resultados finales&#10;    print(f&quot;\ncampeón australian open 2025: {champion[0]}&quot;)&#10;    print(f&quot;finalista: {f_results[0]['loser']}&quot;)&#10;    print(f&quot;semifinalistas: {', '.join([r['loser'] for r in sf_results])}&quot;)&#10;&#10;    # mostrar algunos elos finales de jugadores top&#10;    top_players = [&quot;Jannik Sinner&quot;, &quot;Novak Djokovic&quot;, &quot;Carlos Alcaraz&quot;, &quot;Daniil Medvedev&quot;]&#10;    print(f&quot;\nelos finales después del torneo:&quot;)&#10;    for player in top_players:&#10;        if player in current_elos:&#10;            print(f&quot;  {player}: {current_elos[player]:.0f}&quot;)&#10;&#10;    # guardar resultados&#10;    results_df = pd.DataFrame(all_results)&#10;    output_path = os.path.join(BASE_DIR, &quot;outputs&quot;, &quot;australian_open_2025_results.csv&quot;)&#10;    os.makedirs(os.path.dirname(output_path), exist_ok=True)&#10;    results_df.to_csv(output_path, index=False)&#10;&#10;    print(f&quot;\nresultados guardados en: {output_path}&quot;)&#10;&#10;    return results_df, champion[0]&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    results, champion = simulate_australian_open_2025()&#10;    print(f&quot;\n simulación completada - campeón: {champion}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test_without_h2h.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test_without_h2h.py" />
              <option name="updatedContent" value="import pandas as pd&#10;import os&#10;from sklearn.metrics import accuracy_score&#10;from xgboost import XGBClassifier&#10;from data_loader import BASE_DIR&#10;&#10;# Cargar datos existentes&#10;features_train_path = os.path.join(BASE_DIR, &quot;data&quot;, &quot;processed&quot;, &quot;features_train.csv&quot;)&#10;features_test_path = os.path.join(BASE_DIR, &quot;data&quot;, &quot;processed&quot;, &quot;features_test.csv&quot;)&#10;&#10;def make_dual_rows(df):&#10;    df1 = df.copy()&#10;    df1[&quot;target&quot;] = 1&#10;&#10;    df2 = df.copy()&#10;    df2[&quot;target&quot;] = 0&#10;    for col in [&quot;elo_winner&quot;, &quot;elo_loser&quot;, &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;]:&#10;        tmp = df2[col.replace(&quot;winner&quot;, &quot;loser&quot;)]&#10;        df2[col.replace(&quot;winner&quot;, &quot;loser&quot;)] = df2[col]&#10;        df2[col] = tmp&#10;    return pd.concat([df1, df2], ignore_index=True)&#10;&#10;# Cargar datos&#10;df_train = pd.read_csv(features_train_path)&#10;df_test = pd.read_csv(features_test_path)&#10;&#10;df_train = make_dual_rows(df_train)&#10;df_test[&quot;target&quot;] = 1&#10;&#10;# SOLO usar ELO ratings, sin H2H&#10;feature_cols = [&#10;    &quot;elo_winner&quot;, &quot;elo_loser&quot;,&#10;    &quot;surface_elo_winner&quot;, &quot;surface_elo_loser&quot;&#10;]&#10;&#10;print(&quot; Entrenando modelo SIN features H2H...&quot;)&#10;&#10;X_train = df_train[feature_cols]&#10;y_train = df_train[&quot;target&quot;]&#10;X_test = df_test[feature_cols]&#10;y_test = df_test[&quot;target&quot;]&#10;&#10;model = XGBClassifier(n_estimators=100, random_state=42, eval_metric='logloss')&#10;model.fit(X_train, y_train)&#10;&#10;y_pred = model.predict(X_test)&#10;test_acc = accuracy_score(y_test, y_pred)&#10;print(f&quot; Accuracy en test (SOLO ELO): {test_acc:.4f}&quot;)&#10;&#10;# Mostrar importancia de features&#10;importances = model.feature_importances_&#10;feature_importance_df = pd.DataFrame({&#10;    'Feature': feature_cols,&#10;    'Importance': importances&#10;}).sort_values('Importance', ascending=False)&#10;&#10;print(&quot;\n Importancia de features (solo ELO):&quot;)&#10;print(feature_importance_df)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>